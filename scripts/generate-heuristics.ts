#!/usr/bin/env -S node --enable-source-maps
/*
  Generates HEURISTICS_MAP from Supabase categories_subcategories.
  - Reads NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY from env
  - Tokenizes description, service type and subcategory
  - Writes app/api/classify/heuristics.generated.ts
*/

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import dotenv from "dotenv";
dotenv.config({ path: path.resolve(process.cwd(), ".env.local") });
dotenv.config({ path: path.resolve(process.cwd(), ".env") });

import { createClient } from "@supabase/supabase-js";

function norm(s: unknown): string {
  return String(s ?? "")
    .normalize("NFD")
    .replace(/\p{Diacritic}+/gu, "")
    .toLowerCase()
    .replace(/[^a-z0-9ñáéíóúü\s/.-]/gi, " ")
    .replace(/[\s/.-]+/g, " ")
    .trim();
}

const STOPWORDS = new Set(
  [
    "de",
    "la",
    "el",
    "los",
    "las",
    "y",
    "o",
    "para",
    "con",
    "por",
    "un",
    "una",
    "en",
    "del",
    "al",
    "mi",
    "su",
    "que",
    "es",
    "se",
    "me",
    "tengo",
    "necesito",
    "busco",
    "quiero",
    "debo",
    "hacer",
    "servicio",
    "arreglo",
    "arreglar",
    "reparacion",
    "reparar",
    "instalacion",
    "instalar",
    "ayuda",
  ].map((w) => norm(w)),
);

function tokenize(s: string): string[] {
  return norm(s)
    .split(" ")
    .filter((t) => t.length >= 3 && !STOPWORDS.has(t));
}

function isActive(v: unknown): boolean {
  if (typeof v === "boolean") return v;
  if (typeof v === "number") return v === 1;
  const s = String(v ?? "").trim().toLowerCase();
  return (
    s === "sí" ||
    s === "si" ||
    s === "true" ||
    s === "1" ||
    s === "activo" ||
    s === "activa" ||
    s === "x"
  );
}

async function main() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const service = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !service) {
    console.error("Faltan NEXT_PUBLIC_SUPABASE_URL o SUPABASE_SERVICE_ROLE_KEY");
    process.exit(1);
  }
  const admin = createClient(url, service, { auth: { persistSession: false } });
  const { data, error } = await admin
    .from("categories_subcategories")
    .select('"Categoría","Subcategoría","Descripción","Activa","Ícono","Tipo de servicio","Nivel de especialización"');
  if (error) {
    console.error("DB_ERROR:", error.message);
    process.exit(1);
  }
  const rows = (Array.isArray(data) ? data : []) as Array<Record<string, unknown>>;

  const map = new Map<string, Set<string>>();
  for (const r of rows) {
    if (!isActive(r["Activa"])) continue;
    const sub = String(r["Subcategoría"] ?? "").trim();
    const cat = String(r["Categoría"] ?? "").trim();
    if (!sub && !cat) continue;
    const key = norm(sub || cat);
    const set = map.get(key) ?? new Set<string>();
    const desc = String(r["Descripción"] ?? "");
    const type = String(r["Tipo de servicio"] ?? "");
    const kSub = tokenize(sub).filter((t) => t.length >= 4).slice(0, 3);
    const kType = tokenize(type).filter((t) => t.length >= 4).slice(0, 5);
    const kDesc = tokenize(desc).filter((t) => t.length >= 4).slice(0, 8);
    for (const t of [...kDesc, ...kType, ...kSub]) set.add(t);
    map.set(key, set);
  }

  // Build .ts file
  const outObj: Record<string, string> = {};
  for (const [k, set] of map.entries()) {
    // sort for stable output
    const arr = Array.from(set.values()).sort((a, b) => a.localeCompare(b));
    outObj[k] = arr.join(", ");
  }

  const header = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY\n` +
    `// Generated by scripts/generate-heuristics.ts\n` +
    `// Keys: normalized subcategory names (lowercase, no accents)\n` +
    `// Values: frequent keywords separated by commas/spaces\n\n`;
  const body = `export const HEURISTICS_MAP: Record<string, string> = ${JSON.stringify(outObj, null, 2)} as const;\n`;
  const content = header + body;

  const target = path.resolve(process.cwd(), "app/api/classify/heuristics.generated.ts");
  fs.writeFileSync(target, content, "utf-8");
  console.log("Wrote:", path.relative(process.cwd(), target));
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});

